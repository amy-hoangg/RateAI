import { SQLQuery, Queryable } from '@databases/pg';
import { BulkOperationOptions } from '@databases/pg-bulk';
declare const NO_RESULT_FOUND = "NO_RESULT_FOUND";
declare const MULTIPLE_RESULTS_FOUND = "MULTIPLE_RESULTS_FOUND";
export declare function isNoResultFoundError(err: unknown): err is Error & {
    code: typeof NO_RESULT_FOUND;
};
export declare function isMultipleResultsFoundError(err: unknown): err is Error & {
    code: typeof MULTIPLE_RESULTS_FOUND;
};
export interface DatabaseSchemaColumn {
    readonly name: string;
    readonly isNullable: boolean;
    readonly hasDefault: boolean;
    readonly typeId: number;
    readonly typeName: string | null;
}
export interface DatabaseSchemaTable {
    readonly name: string;
    readonly columns: readonly DatabaseSchemaColumn[];
}
export type UnorderedSelectQueryMethods = 'toSql' | 'one' | 'oneRequired' | 'all' | 'select' | 'distinct' | 'orderByAscDistinct' | 'orderByDescDistinct' | 'orderByAsc' | 'orderByDesc' | 'andWhere';
export type SelectQueryMethods = UnorderedSelectQueryMethods | 'first' | 'limit';
export interface SelectQuery<TRecord, TMethods extends SelectQueryMethods> {
    toSql(): SQLQuery;
    one(): Promise<TRecord | null>;
    oneRequired(): Promise<TRecord>;
    all(): Promise<TRecord[]>;
    first(): Promise<TRecord | null>;
    limit(count: number): Promise<TRecord[]>;
    select<TKeys extends readonly [keyof TRecord, ...(readonly (keyof TRecord)[])]>(...fields: TKeys): PartialSelectQuery<Pick<TRecord, TKeys[number]>, Exclude<TMethods, 'select'>>;
    distinct(...columns: readonly (keyof TRecord)[]): PartialSelectQuery<TRecord, Exclude<TMethods, 'distinct' | 'orderByAscDistinct' | 'orderByDescDistinct' | 'orderByAsc' | 'orderByDesc'>>;
    orderByAscDistinct(key: keyof TRecord): PartialSelectQuery<TRecord, Exclude<TMethods, 'distinct'> | 'first' | 'limit'>;
    orderByDescDistinct(key: keyof TRecord): PartialSelectQuery<TRecord, Exclude<TMethods, 'distinct'> | 'first' | 'limit'>;
    orderByAsc(key: keyof TRecord): PartialSelectQuery<TRecord, Exclude<TMethods, 'distinct' | 'orderByAscDistinct' | 'orderByDescDistinct'> | 'first' | 'limit'>;
    orderByDesc(key: keyof TRecord): PartialSelectQuery<TRecord, Exclude<TMethods, 'distinct' | 'orderByAscDistinct' | 'orderByDescDistinct'> | 'first' | 'limit'>;
    andWhere(condition: WhereCondition<TRecord>): this;
}
export type PartialSelectQuery<TRecord, TMethods extends SelectQueryMethods> = Pick<SelectQuery<TRecord, TMethods>, TMethods>;
export type UnorderedSelectQuery<TRecord> = PartialSelectQuery<TRecord, UnorderedSelectQueryMethods>;
type SpecialFieldQuery<T> = {
    type: 'json_path';
    path: readonly string[];
    query: T | FieldQuery<T>;
} | {
    type: 'case_insensitive';
    query: T | FieldQuery<T>;
} | {
    type: 'not';
    query: T | FieldQuery<T>;
};
declare class FieldQuery<T> {
    protected readonly __query: (columnName: SQLQuery, sql: Queryable['sql'], toValue: (value: unknown) => unknown) => SQLQuery | 'TRUE' | 'FALSE';
    protected readonly __special: SpecialFieldQuery<T> | undefined;
    constructor(query: (columnName: SQLQuery, sql: Queryable['sql'], toValue: (value: unknown) => unknown) => SQLQuery | 'TRUE' | 'FALSE', special?: SpecialFieldQuery<T>);
    protected __checkFieldType(): T;
    static query<T>(columnName: SQLQuery, q: FieldQuery<T> | unknown, sql: Queryable['sql'], toValue: (value: unknown) => unknown): SQLQuery | 'TRUE' | 'FALSE';
    static getSpecial<T>(q: T | FieldQuery<T>): SpecialFieldQuery<T> | undefined;
}
export type { FieldQuery };
export declare function anyOf<T>(values: {
    [Symbol.iterator](): IterableIterator<T | FieldQuery<T>>;
}): T | FieldQuery<T>;
export declare function allOf<T>(values: {
    [Symbol.iterator](): IterableIterator<T | FieldQuery<T>>;
}): T | FieldQuery<T>;
export declare function not<T>(value: T | FieldQuery<T>): T | FieldQuery<T>;
export declare function inQueryResults(query: SQLQuery): FieldQuery<any>;
export declare function lessThan<T>(value: T): FieldQuery<T>;
export declare function greaterThan<T>(value: T): FieldQuery<T>;
export declare function jsonPath(path: readonly string[], query: any | FieldQuery<any>): FieldQuery<any>;
export declare function caseInsensitive(query: string | FieldQuery<string>): FieldQuery<string>;
declare class WhereCombinedCondition<TRecord> {
    protected readonly __conditions: readonly WhereCondition<TRecord>[];
    protected readonly __combiner: 'AND' | 'OR';
    constructor(conditions: readonly WhereCondition<TRecord>[], combiner: 'AND' | 'OR');
    static query<T>(recordIdentifier: string | null, q: WhereCondition<T>, sql: Queryable['sql'], toValue: (columnName: string, value: unknown) => unknown, parentType?: 'AND' | 'OR'): SQLQuery | 'TRUE' | 'FALSE';
}
export type { WhereCombinedCondition };
export type WhereCondition<TRecord> = Partial<{
    readonly [key in keyof TRecord]: TRecord[key] | FieldQuery<TRecord[key]>;
}> | WhereCombinedCondition<TRecord> | SQLQuery;
export declare function and<TRecord>(...conditions: readonly WhereCondition<TRecord>[]): WhereCondition<TRecord>;
export declare function or<TRecord>(...conditions: readonly WhereCondition<TRecord>[]): WhereCondition<TRecord>;
type BulkRecord<TParameters, TKey extends keyof TParameters> = {
    readonly [key in TKey]-?: Exclude<TParameters[key], undefined>;
} & {
    readonly [key in Exclude<keyof TParameters, TKey>]?: undefined;
};
type BulkInsertFields<TInsertParameters, TKey extends keyof TInsertParameters> = TKey | {
    readonly [K in keyof TInsertParameters]: undefined extends TInsertParameters[K] ? never : K;
}[keyof TInsertParameters];
type BulkInsertRecord<TInsertParameters, TKey extends keyof TInsertParameters> = BulkRecord<TInsertParameters, BulkInsertFields<TInsertParameters, TKey>>;
declare class Table<TRecord, TInsertParameters> {
    private readonly _underlyingDb;
    readonly tableId: SQLQuery;
    readonly tableName: string;
    private readonly _value;
    private readonly _bulkOperationOptions;
    constructor(_underlyingDb: Queryable, tableId: SQLQuery, tableName: string, serializeValue: (columnName: string, value: unknown) => unknown, bulkOperationOptions: (BulkOperationOptions<keyof TRecord | keyof TInsertParameters> & {
        requiredInsertColumnNames: readonly (keyof TInsertParameters)[];
    }) | undefined);
    private _getBulkOperationOptions;
    conditionToSql(condition: WhereCondition<TRecord>, tableAlias?: string): SQLQuery;
    bulkInsert<TColumnsToInsert extends readonly [
        ...(readonly (keyof TInsertParameters)[])
    ]>({ columnsToInsert, records, }: {
        readonly columnsToInsert: TColumnsToInsert;
        readonly records: readonly BulkInsertRecord<TInsertParameters, TColumnsToInsert[number]>[];
    }): Promise<TRecord[]>;
    bulkInsertOrIgnore<TColumnsToInsert extends readonly [
        ...(readonly (keyof TInsertParameters)[])
    ]>({ columnsToInsert, records, }: {
        readonly columnsToInsert: TColumnsToInsert;
        readonly records: readonly BulkInsertRecord<TInsertParameters, TColumnsToInsert[number]>[];
    }): Promise<TRecord[]>;
    bulkInsertOrUpdate<TColumnsToInsert extends readonly [
        ...(readonly (keyof TInsertParameters)[])
    ]>({ columnsToInsert, columnsThatConflict, columnsToUpdate, records, }: {
        readonly columnsToInsert: TColumnsToInsert;
        readonly columnsThatConflict: readonly [
            TColumnsToInsert[number],
            ...TColumnsToInsert[number][]
        ];
        readonly columnsToUpdate: readonly [
            TColumnsToInsert[number],
            ...TColumnsToInsert[number][]
        ];
        readonly records: readonly BulkInsertRecord<TInsertParameters, TColumnsToInsert[number]>[];
    }): Promise<TRecord[]>;
    bulkFind<TWhereColumns extends readonly [...(readonly (keyof TRecord)[])]>({ whereColumnNames, whereConditions, }: {
        readonly whereColumnNames: TWhereColumns;
        readonly whereConditions: readonly BulkRecord<TRecord, TWhereColumns[number]>[];
    }): UnorderedSelectQuery<TRecord>;
    bulkUpdate<TWhereColumns extends readonly [...(readonly (keyof TRecord)[])], TSetColumns extends readonly [...(readonly (keyof TRecord)[])]>({ whereColumnNames, setColumnNames, updates, }: {
        readonly whereColumnNames: TWhereColumns;
        readonly setColumnNames: TSetColumns;
        readonly updates: readonly {
            readonly where: BulkRecord<TRecord, TWhereColumns[number]>;
            readonly set: BulkRecord<TRecord, TSetColumns[number]>;
        }[];
    }): Promise<TRecord[]>;
    bulkDelete<TWhereColumns extends readonly [...(readonly (keyof TRecord)[])]>({ whereColumnNames, whereConditions, }: {
        readonly whereColumnNames: TWhereColumns;
        readonly whereConditions: readonly BulkRecord<TRecord, TWhereColumns[number]>[];
    }): Promise<void>;
    private _insert;
    insert<TRecordsToInsert extends readonly TInsertParameters[]>(...rows: keyof TRecordsToInsert[number] extends keyof TInsertParameters ? TRecordsToInsert : readonly ({
        readonly [key in keyof TInsertParameters]: TInsertParameters[key];
    } & {
        readonly [key in Exclude<keyof TRecordsToInsert[number], keyof TInsertParameters>]: never;
    })[]): Promise<{
        -readonly [key in keyof TRecordsToInsert]: TRecord;
    }>;
    insertOrUpdate<TRecordsToInsert extends readonly TInsertParameters[]>(options: readonly [keyof TRecord, ...(keyof TRecord)[]] | {
        onConflict: readonly [keyof TRecord, ...(keyof TRecord)[]];
        set?: readonly [keyof TRecord, ...(keyof TRecord)[]];
        doNotSet?: undefined;
    } | {
        onConflict: readonly [keyof TRecord, ...(keyof TRecord)[]];
        set?: undefined;
        doNotSet?: readonly [keyof TRecord, ...(keyof TRecord)[]];
    }, ...rows: keyof TRecordsToInsert[number] extends keyof TInsertParameters ? TRecordsToInsert : readonly ({
        [key in keyof TInsertParameters]: TInsertParameters[key];
    } & {
        [key in Exclude<keyof TRecordsToInsert[number], keyof TInsertParameters>]: never;
    })[]): Promise<{
        -readonly [key in keyof TRecordsToInsert]: TRecord;
    }>;
    insertOrIgnore<TRecordsToInsert extends readonly TInsertParameters[]>(...rows: keyof TRecordsToInsert[number] extends keyof TInsertParameters ? TRecordsToInsert : readonly ({
        readonly [key in keyof TInsertParameters]: TInsertParameters[key];
    } & {
        readonly [key in Exclude<keyof TRecordsToInsert[number], keyof TInsertParameters>]: never;
    })[]): Promise<TRecord[]>;
    update(whereValues: WhereCondition<TRecord>, updateValues: Partial<TRecord>): Promise<TRecord[]>;
    delete(whereValues: WhereCondition<TRecord>): Promise<void>;
    /**
     * @deprecated use .find instead of .select
     */
    select(whereValues?: WhereCondition<TRecord>): UnorderedSelectQuery<TRecord>;
    private _findUntyped;
    find(whereValues?: WhereCondition<TRecord>): UnorderedSelectQuery<TRecord>;
    /**
     * @deprecated use .findOne instead of .selectOne
     */
    selectOne(whereValues: WhereCondition<TRecord>): Promise<TRecord | null>;
    findOne(whereValues: WhereCondition<TRecord>): Promise<TRecord | null>;
    findOneRequired(whereValues: WhereCondition<TRecord>): Promise<TRecord>;
    count(whereValues?: WhereCondition<TRecord>): Promise<number>;
    untypedQuery(query: SQLQuery): Promise<TRecord[]>;
}
export type { Table };
type TableHelperFunction<TMissingOptions extends keyof PgTypedOptions, TResult> = 'defaultConnection' extends TMissingOptions ? (connectionOrTransaction: Queryable) => TResult : (connectionOrTransaction?: Queryable) => TResult;
type AssertKeyOfTable<TKey extends keyof Table<any, any>> = TKey;
type PropertiesThatRequireDbSchema = AssertKeyOfTable<'bulkDelete' | 'bulkFind' | 'bulkInsert' | 'bulkUpdate'>;
export type TableHelper<TRecord, TInsertParameters, TMissingOptions extends keyof PgTypedOptions = never> = {
    key: <TKey extends keyof TRecord>(fieldName: TKey, condition?: WhereCondition<TRecord>) => FieldQuery<TRecord[TKey]>;
} & TableHelperFunction<TMissingOptions, 'databaseSchema' extends TMissingOptions ? Omit<Table<TRecord, TInsertParameters>, PropertiesThatRequireDbSchema> : Table<TRecord, TInsertParameters>>;
export interface PgTypedOptions {
    schemaName?: string;
    serializeValue?: (tableName: string, columnName: string, value: unknown) => unknown;
    defaultConnection: Queryable;
    databaseSchema: DatabaseSchemaTable[];
}
export default function defineTables<TTables>(options: PgTypedOptions): {
    [TTableName in keyof TTables]: TableHelper<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>>;
};
export default function defineTables<TTables>(options: Omit<PgTypedOptions, 'defaultConnection'>): {
    [TTableName in keyof TTables]: TableHelper<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>, 'defaultConnection'>;
};
export default function defineTables<TTables>(options: Omit<PgTypedOptions, 'databaseSchema'>): {
    [TTableName in keyof TTables]: TableHelper<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>, 'databaseSchema'>;
};
export default function defineTables<TTables>(options?: Omit<PgTypedOptions, 'databaseSchema' | 'defaultConnection'>): {
    [TTableName in keyof TTables]: TableHelper<PropertyOf<TTables[TTableName], 'record'>, PropertyOf<TTables[TTableName], 'insert'>, 'databaseSchema' | 'defaultConnection'>;
};
type PropertyOf<T, TProp extends string> = T extends {
    [k in TProp]: infer TValue;
} ? TValue : never;
