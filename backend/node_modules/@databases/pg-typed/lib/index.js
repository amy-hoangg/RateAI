"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.or = exports.and = exports.caseInsensitive = exports.jsonPath = exports.greaterThan = exports.lessThan = exports.inQueryResults = exports.not = exports.allOf = exports.anyOf = exports.isMultipleResultsFoundError = exports.isNoResultFoundError = void 0;
const assert_never_1 = require("assert-never");
const pg_bulk_1 = require("@databases/pg-bulk");
const NO_RESULT_FOUND = `NO_RESULT_FOUND`;
const MULTIPLE_RESULTS_FOUND = `MULTIPLE_RESULTS_FOUND`;
function isNoResultFoundError(err) {
    return (typeof err === 'object' &&
        err !== null &&
        err instanceof Error &&
        err.code === NO_RESULT_FOUND);
}
exports.isNoResultFoundError = isNoResultFoundError;
function isMultipleResultsFoundError(err) {
    return (typeof err === 'object' &&
        err !== null &&
        err instanceof Error &&
        err.code === MULTIPLE_RESULTS_FOUND);
}
exports.isMultipleResultsFoundError = isMultipleResultsFoundError;
class FieldQuery {
    constructor(query, special) {
        this.__query = query;
        this.__special = special;
    }
    __checkFieldType() {
        throw new Error('This method is only there to help TypeScript interpret the type');
    }
    static query(columnName, q, sql, toValue) {
        if (q === null) {
            return sql `${columnName} IS NULL`;
        }
        if (q && q instanceof FieldQuery) {
            return q.__query(columnName, sql, toValue);
        }
        return sql `${columnName} = ${toValue(q)}`;
    }
    static getSpecial(q) {
        if (q && q instanceof FieldQuery) {
            return q.__special;
        }
        else {
            return undefined;
        }
    }
}
function anyOf(values) {
    const valuesSet = new Set();
    const parts = [];
    const caseInsensitiveParts = [];
    const negatedParts = [];
    for (const value of values) {
        if (value === null) {
            parts.push(new FieldQuery((columnName, sql, toValue) => FieldQuery.query(columnName, null, sql, toValue)));
        }
        else if (value instanceof FieldQuery) {
            const special = FieldQuery.getSpecial(value);
            if ((special === null || special === void 0 ? void 0 : special.type) === 'case_insensitive') {
                caseInsensitiveParts.push(special.query);
            }
            else if ((special === null || special === void 0 ? void 0 : special.type) === 'not') {
                negatedParts.push(special.query);
            }
            else {
                parts.push(value);
            }
        }
        else {
            valuesSet.add(value);
        }
    }
    if (caseInsensitiveParts.length) {
        parts.push(caseInsensitive(anyOf(caseInsensitiveParts)));
    }
    if (negatedParts.length) {
        const negated = not(allOf(negatedParts));
        if (negated && negated instanceof FieldQuery) {
            parts.push(negated);
        }
        else {
            valuesSet.add(negated);
        }
    }
    if (valuesSet.size) {
        if (valuesSet.size === 1) {
            parts.push(new FieldQuery((columnName, sql, toValue) => FieldQuery.query(columnName, [...valuesSet][0], sql, toValue)));
        }
        else {
            parts.push(new FieldQuery((columnName, sql, toValue) => sql `${columnName} = ANY(${[...valuesSet].map((v) => toValue(v))})`));
        }
    }
    return new FieldQuery((columnName, sql, toValue) => {
        const sqlParts = [];
        for (const p of parts) {
            const part = FieldQuery.query(columnName, p, sql, toValue);
            if (part === 'TRUE')
                return 'TRUE';
            if (part !== 'FALSE')
                sqlParts.push(part);
        }
        if (sqlParts.length === 0)
            return 'FALSE';
        if (sqlParts.length === 1)
            return sqlParts[0];
        return sql `(${sql.join(sqlParts, ' OR ')})`;
    });
}
exports.anyOf = anyOf;
function allOf(values) {
    const valuesSet = new Set();
    const parts = [];
    const negated = [];
    for (const q of values) {
        if (q && q instanceof FieldQuery) {
            const special = FieldQuery.getSpecial(q);
            if ((special === null || special === void 0 ? void 0 : special.type) === 'not') {
                negated.push(special.query);
            }
            else {
                parts.push(q);
            }
        }
        else {
            valuesSet.add(q);
        }
    }
    if (negated.length) {
        const n = not(anyOf(negated));
        if (n && n instanceof FieldQuery) {
            parts.push(n);
        }
        else {
            valuesSet.add(n);
        }
    }
    if (valuesSet.size > 1) {
        return new FieldQuery(() => `FALSE`);
    }
    else if (valuesSet.size) {
        parts.push(new FieldQuery((columnName, sql, toValue) => FieldQuery.query(columnName, [...valuesSet][0], sql, toValue)));
    }
    return new FieldQuery((columnName, sql, toValue) => {
        const sqlParts = [];
        for (const p of parts) {
            const part = FieldQuery.query(columnName, p, sql, toValue);
            if (part === 'FALSE')
                return 'FALSE';
            if (part !== 'TRUE')
                sqlParts.push(part);
        }
        if (sqlParts.length === 0)
            return 'TRUE';
        if (sqlParts.length === 1)
            return sqlParts[0];
        return sql `(${sql.join(sqlParts, ' AND ')})`;
    });
}
exports.allOf = allOf;
function not(value) {
    const special = FieldQuery.getSpecial(value);
    if ((special === null || special === void 0 ? void 0 : special.type) === 'not') {
        return special.query;
    }
    return new FieldQuery((columnName, sql, toValue) => {
        const subQuery = FieldQuery.query(columnName, value, sql, toValue);
        if (subQuery === 'TRUE')
            return 'FALSE';
        if (subQuery === 'FALSE')
            return 'TRUE';
        return sql `NOT (${subQuery})`;
    }, { type: 'not', query: value });
}
exports.not = not;
function internalInQueryResults(query) {
    return new FieldQuery((columnName, sql) => {
        const subQuery = query(sql);
        if (!sql.isSqlQuery(subQuery))
            return subQuery;
        return sql `${columnName} IN (${subQuery})`;
    });
}
function inQueryResults(query) {
    return internalInQueryResults(() => query);
}
exports.inQueryResults = inQueryResults;
function lessThan(value) {
    return new FieldQuery((columnName, sql, toValue) => sql `${columnName} < ${toValue(value)}`);
}
exports.lessThan = lessThan;
function greaterThan(value) {
    return new FieldQuery((columnName, sql, toValue) => sql `${columnName} > ${toValue(value)}`);
}
exports.greaterThan = greaterThan;
function jsonPath(path, query) {
    return new FieldQuery((columnName, sql, toValue) => FieldQuery.query(sql `${columnName}#>${path}`, query, sql, toValue), { type: 'json_path', path, query });
}
exports.jsonPath = jsonPath;
function caseInsensitive(query) {
    const special = FieldQuery.getSpecial(query);
    if ((special === null || special === void 0 ? void 0 : special.type) === 'json_path') {
        return jsonPath(special.path, caseInsensitive(special.query));
    }
    return new FieldQuery((columnName, sql, toValue) => FieldQuery.query(sql `LOWER(CAST(${columnName} AS TEXT))`, query, sql, (v) => `${toValue(v)}`.toLowerCase()), { type: 'case_insensitive', query });
}
exports.caseInsensitive = caseInsensitive;
class WhereCombinedCondition {
    constructor(conditions, combiner) {
        this.__conditions = conditions;
        this.__combiner = combiner;
    }
    static query(recordIdentifier, q, sql, toValue, parentType) {
        if (q instanceof WhereCombinedCondition) {
            const conditions = q.__conditions.map((c) => WhereCombinedCondition.query(recordIdentifier, c, sql, toValue, q.__combiner));
            const significantConditions = [];
            switch (q.__combiner) {
                case 'AND': {
                    for (const c of conditions) {
                        if (c === 'FALSE')
                            return 'FALSE';
                        if (c !== 'TRUE')
                            significantConditions.push(c);
                    }
                    if (!significantConditions.length)
                        return 'TRUE';
                    if (significantConditions.length === 1) {
                        return significantConditions[0];
                    }
                    const query = sql.join(significantConditions, sql ` AND `);
                    return parentType === 'OR' ? sql `(${query})` : query;
                }
                case 'OR': {
                    for (const c of conditions) {
                        if (c === 'TRUE')
                            return 'TRUE';
                        if (c !== 'FALSE')
                            significantConditions.push(c);
                    }
                    if (!significantConditions.length)
                        return 'FALSE';
                    if (significantConditions.length === 1) {
                        return significantConditions[0];
                    }
                    const query = sql.join(significantConditions, sql ` OR `);
                    return parentType === 'AND' ? sql `(${query})` : query;
                }
                default:
                    return (0, assert_never_1.default)(q.__combiner);
            }
        }
        if (typeof sql.isSqlQuery === 'function' && sql.isSqlQuery(q)) {
            return q;
        }
        const entries = Object.entries(q);
        const fieldTests = [];
        for (const [columnName, value] of entries) {
            const sqlFieldTest = FieldQuery.query(recordIdentifier
                ? sql.ident(recordIdentifier, columnName)
                : sql.ident(columnName), value, sql, (v) => toValue(columnName, v));
            if (sqlFieldTest === 'FALSE')
                return 'FALSE';
            if (sqlFieldTest !== 'TRUE')
                fieldTests.push(sqlFieldTest);
        }
        if (fieldTests.length === 0) {
            return 'TRUE';
        }
        if (fieldTests.length === 1) {
            return fieldTests[0];
        }
        const query = sql.join(fieldTests, sql ` AND `);
        return parentType === 'OR' ? sql `(${query})` : query;
    }
}
function and(...conditions) {
    return new WhereCombinedCondition(conditions, 'AND');
}
exports.and = and;
function or(...conditions) {
    return new WhereCombinedCondition(conditions, 'OR');
}
exports.or = or;
class SelectQueryImplementation {
    constructor(_tableId, _tableName, _sql, _value, _whereCondition, _executeQuery) {
        this._tableId = _tableId;
        this._tableName = _tableName;
        this._sql = _sql;
        this._value = _value;
        this._whereCondition = _whereCondition;
        this._executeQuery = _executeQuery;
        this._orderByQueries = [];
        this._whereAnd = [];
    }
    async _getResults(mode) {
        if (this._methodCalled) {
            throw new Error(`You cannot use the same query multiple times. ${this._methodCalled} has already been called on this query.`);
        }
        this._methodCalled = mode;
        const query = this._toSql(false);
        if (!query)
            return [];
        return this._executeQuery(query);
    }
    _toSql(required) {
        const sql = this._sql;
        const selectFields = this._selectFields;
        const orderByQueries = this._orderByQueries;
        const limitCount = this._limitCount;
        const distinctColumnNames = this._distinctColumnNames;
        const whereCondition = this._whereCondition === `FALSE`
            ? `FALSE`
            : WhereCombinedCondition.query(null, new WhereCombinedCondition(this._whereCondition === `TRUE`
                ? this._whereAnd
                : [this._whereCondition, ...this._whereAnd], 'AND'), sql, this._value);
        if (whereCondition === `FALSE` && !required)
            return undefined;
        return sql.join([
            sql `SELECT`,
            (distinctColumnNames === null || distinctColumnNames === void 0 ? void 0 : distinctColumnNames.length)
                ? sql `DISTINCT ON (${sql.join(distinctColumnNames.map((f) => sql.ident(f)), `,`)})`
                : distinctColumnNames
                    ? sql `DISTINCT`
                    : null,
            selectFields
                ? sql.join(selectFields.map((f) => sql.ident(f)), ',')
                : sql `*`,
            sql `FROM ${this._tableId}`,
            whereCondition === `TRUE`
                ? null
                : whereCondition === `FALSE`
                    ? sql `WHERE FALSE`
                    : sql `WHERE ${whereCondition}`,
            orderByQueries.length
                ? sql `ORDER BY ${sql.join(orderByQueries.map((q) => q.direction === 'ASC'
                    ? sql `${sql.ident(q.columnName)} ASC`
                    : sql `${sql.ident(q.columnName)} DESC`), sql `, `)}`
                : null,
            limitCount ? sql `LIMIT ${limitCount}` : null,
        ].filter((v) => v !== null), sql ` `);
    }
    toSql() {
        if (this._methodCalled) {
            throw new Error(`You cannot use the same query multiple times. ${this._methodCalled} has already been called on this query.`);
        }
        this._methodCalled = `toSql`;
        return this._toSql(true);
    }
    distinct(...columnNames) {
        if (this._distinctColumnNames || this._orderByQueries.length) {
            throw new Error(`Cannot add distinct field after adding order by field or add distinct multiple times without ordering`);
        }
        this._distinctColumnNames = columnNames.slice();
        return this;
    }
    _orderByDistinct(columnName, direction) {
        if (this._distinctColumnNames && !this._distinctColumnNames.length) {
            throw new Error(`Cannot call orderByAscDistinct or orderByDescDistinct after calling distinct`);
        }
        if (!this._distinctColumnNames)
            this._distinctColumnNames = [];
        if (this._distinctColumnNames.length !== this._orderByQueries.length) {
            throw new Error(`Cannot call orderByAscDistinct or orderByDescDistinct after calling orderByAscDistinct or orderByDescDistinct`);
        }
        this._distinctColumnNames.push(columnName);
        return this._orderBy(columnName, direction);
    }
    orderByAscDistinct(columnName) {
        return this._orderByDistinct(columnName, `ASC`);
    }
    orderByDescDistinct(columnName) {
        return this._orderByDistinct(columnName, `DESC`);
    }
    _orderBy(columnName, direction) {
        this._orderByQueries.push({ columnName, direction });
        return this;
    }
    orderByAsc(columnName) {
        return this._orderBy(columnName, `ASC`);
    }
    orderByDesc(columnName) {
        return this._orderBy(columnName, `DESC`);
    }
    andWhere(condition) {
        this._whereAnd.push(condition);
        return this;
    }
    select(...fields) {
        if (this._selectFields) {
            throw new Error('Cannot call select fields multiple times on one query');
        }
        this._selectFields = fields;
        return this;
    }
    async all() {
        return await this._getResults('all');
    }
    async limit(count) {
        if (!this._orderByQueries.length) {
            throw new Error('You cannot call "limit" until after you call "orderByAsc" or "orderByDesc".');
        }
        this._limitCount = count;
        return await this._getResults('limit');
    }
    async first() {
        if (!this._orderByQueries.length) {
            throw new Error('You cannot call "first" until after you call "orderByAsc" or "orderByDesc".');
        }
        this._limitCount = 1;
        const results = await this._getResults('first');
        return results.length ? results[0] : null;
    }
    async one() {
        const results = await this._getResults('only');
        if (results.length > 1) {
            throw Object.assign(new Error(`More than one row matched this query on ${this._tableName} but we only expected one.`), { code: MULTIPLE_RESULTS_FOUND });
        }
        if (results.length === 0) {
            return null;
        }
        return results[0];
    }
    async oneRequired() {
        const result = await this.one();
        if (result === null) {
            throw Object.assign(new Error(`No results matched this query on ${this._tableName}.`), { code: NO_RESULT_FOUND });
        }
        return result;
    }
}
function getBulkOperationOptionsBase(table, { sql, schemaName, serializeValue, }) {
    return {
        tableName: table.name,
        columnTypes: Object.fromEntries(table.columns.map((c) => [
            c.name,
            sql.__dangerous__rawValue(`${c.typeName}`),
        ])),
        schemaName,
        serializeValue,
        requiredInsertColumnNames: table.columns
            .filter((c) => !c.isNullable && !c.hasDefault)
            .map((c) => c.name),
    };
}
class Table {
    constructor(_underlyingDb, tableId, tableName, serializeValue, bulkOperationOptions) {
        this._underlyingDb = _underlyingDb;
        this.tableId = tableId;
        this.tableName = tableName;
        this._value = (c, v) => serializeValue(c, v);
        this._bulkOperationOptions = bulkOperationOptions;
    }
    _getBulkOperationOptions() {
        if (!this._bulkOperationOptions) {
            throw new Error(`You must provide a "databaseSchema" when constructing pg-typed to use bulk operations.`);
        }
        return this._bulkOperationOptions;
    }
    conditionToSql(condition, tableAlias) {
        const query = WhereCombinedCondition.query(tableAlias !== null && tableAlias !== void 0 ? tableAlias : this.tableName, condition, this._underlyingDb.sql, this._value);
        return query === `TRUE`
            ? this._underlyingDb.sql `TRUE`
            : query === `FALSE`
                ? this._underlyingDb.sql `FALSE`
                : query;
    }
    async bulkInsert({ columnsToInsert, records, }) {
        if (records.length === 0) {
            return [];
        }
        const { sql } = this._underlyingDb;
        return await this._underlyingDb.query(sql `${(0, pg_bulk_1.bulkInsertStatement)({
            ...this._getBulkOperationOptions(),
            columnsToInsert: [
                ...new Set([
                    ...columnsToInsert,
                    ...this._getBulkOperationOptions().requiredInsertColumnNames,
                ]),
            ].sort(),
            records,
        })} RETURNING ${this.tableId}.*`);
    }
    async bulkInsertOrIgnore({ columnsToInsert, records, }) {
        if (records.length === 0) {
            return [];
        }
        const { sql } = this._underlyingDb;
        return await this._underlyingDb.query(sql `${(0, pg_bulk_1.bulkInsertStatement)({
            ...this._getBulkOperationOptions(),
            columnsToInsert: [
                ...new Set([
                    ...columnsToInsert,
                    ...this._getBulkOperationOptions().requiredInsertColumnNames,
                ]),
            ].sort(),
            records,
        })} ON CONFLICT DO NOTHING RETURNING ${this.tableId}.*`);
    }
    async bulkInsertOrUpdate({ columnsToInsert, columnsThatConflict, columnsToUpdate, records, }) {
        if (records.length === 0) {
            return [];
        }
        const { sql } = this._underlyingDb;
        return await this._underlyingDb.query(sql `${(0, pg_bulk_1.bulkInsertStatement)({
            ...this._getBulkOperationOptions(),
            columnsToInsert: [
                ...new Set([
                    ...columnsToInsert,
                    ...this._getBulkOperationOptions().requiredInsertColumnNames,
                ]),
            ].sort(),
            records,
        })} ON CONFLICT (${sql.join(columnsThatConflict.map((k) => sql.ident(k)), sql `, `)}) DO UPDATE SET ${sql.join(columnsToUpdate.map((key) => sql `${sql.ident(key)}=EXCLUDED.${sql.ident(key)}`), sql `, `)} RETURNING ${this.tableId}.*`);
    }
    bulkFind({ whereColumnNames, whereConditions, }) {
        const bulkOperationOptions = this._getBulkOperationOptions();
        return this._findUntyped(whereConditions.length
            ? (0, pg_bulk_1.bulkCondition)({
                ...bulkOperationOptions,
                whereColumnNames,
                whereConditions,
            })
            : 'FALSE');
    }
    async bulkUpdate({ whereColumnNames, setColumnNames, updates, }) {
        if (updates.length === 0) {
            return [];
        }
        const { sql } = this._underlyingDb;
        return await (0, pg_bulk_1.bulkUpdate)({
            ...this._getBulkOperationOptions(),
            whereColumnNames,
            setColumnNames,
            updates,
            returning: sql `${this.tableId}.*`,
        });
    }
    async bulkDelete({ whereColumnNames, whereConditions, }) {
        if (whereConditions.length === 0) {
            return;
        }
        await (0, pg_bulk_1.bulkDelete)({
            ...this._getBulkOperationOptions(),
            whereColumnNames,
            whereConditions,
        });
    }
    async _insert(onConflict, ...rows) {
        if (rows.length === 0)
            return [];
        const { sql } = this._underlyingDb;
        const columnNamesSet = new Set();
        for (const row of rows) {
            for (const columnName of Object.keys(row)) {
                columnNamesSet.add(columnName);
            }
        }
        const columnNames = [...columnNamesSet].sort();
        const columnNamesSql = sql.join(columnNames.map((columnName) => sql.ident(columnName)), sql `, `);
        const values = rows.map((row) => sql `(${sql.join(columnNames.map((columnName) => columnName in row
            ? sql.value(this._value(columnName, row[columnName]))
            : sql `DEFAULT`), `,`)})`);
        const results = await this._underlyingDb.query(onConflict
            ? sql `INSERT INTO ${this.tableId} (${columnNamesSql}) VALUES ${sql.join(values, `,`)} ${onConflict(columnNames)} RETURNING *`
            : sql `INSERT INTO ${this.tableId} (${columnNamesSql}) VALUES ${sql.join(values, `,`)} RETURNING *`);
        return results;
    }
    async insert(...rows) {
        return this._insert(null, ...rows);
    }
    async insertOrUpdate(options, ...rows) {
        var _a;
        const getOption = (k) => {
            return Array.isArray(options) ? undefined : options[k];
        };
        const conflictKeys = (_a = getOption('onConflict')) !== null && _a !== void 0 ? _a : options;
        const set = getOption('set');
        const doNotSet = getOption('doNotSet');
        const { sql } = this._underlyingDb;
        return this._insert((columnNames) => {
            let updateKeys = columnNames;
            if (set) {
                updateKeys = set;
            }
            if (doNotSet) {
                const keysNotToSet = new Set(doNotSet);
                updateKeys = updateKeys.filter((key) => !keysNotToSet.has(key));
            }
            return sql `ON CONFLICT (${sql.join(conflictKeys.map((k) => sql.ident(k)), sql `, `)}) DO UPDATE SET ${sql.join(updateKeys.map((key) => sql `${sql.ident(key)}=EXCLUDED.${sql.ident(key)}`), sql `, `)}`;
        }, ...rows);
    }
    async insertOrIgnore(...rows) {
        const { sql } = this._underlyingDb;
        return await this._insert(() => sql `ON CONFLICT DO NOTHING`, ...rows);
    }
    async update(whereValues, updateValues) {
        const { sql } = this._underlyingDb;
        const whereConditions = WhereCombinedCondition.query(null, whereValues, sql, this._value);
        if (whereConditions === `FALSE`) {
            return [];
        }
        const setClause = sql.join(Object.entries(updateValues).map(([columnName, value]) => {
            return sql `${sql.ident(columnName)} = ${this._value(columnName, value)}`;
        }), sql `, `);
        if (whereConditions === 'TRUE') {
            return await this.untypedQuery(sql `UPDATE ${this.tableId} SET ${setClause} RETURNING *`);
        }
        else {
            return await this.untypedQuery(sql `UPDATE ${this.tableId} SET ${setClause} WHERE ${whereConditions} RETURNING *`);
        }
    }
    async delete(whereValues) {
        const { sql } = this._underlyingDb;
        const whereConditions = WhereCombinedCondition.query(null, whereValues, sql, this._value);
        if (whereConditions === 'TRUE') {
            await this.untypedQuery(sql `DELETE FROM ${this.tableId}`);
        }
        else if (whereConditions !== 'FALSE') {
            await this.untypedQuery(sql `DELETE FROM ${this.tableId} WHERE ${whereConditions}`);
        }
    }
    /**
     * @deprecated use .find instead of .select
     */
    select(whereValues = {}) {
        return this.find(whereValues);
    }
    _findUntyped(whereCondition) {
        const { sql } = this._underlyingDb;
        return new SelectQueryImplementation(this.tableId, this.tableName, sql, this._value, whereCondition, async (query) => {
            return await this._underlyingDb.query(query);
        });
    }
    find(whereValues = {}) {
        const { sql } = this._underlyingDb;
        return this._findUntyped(WhereCombinedCondition.query(null, whereValues, sql, this._value));
    }
    /**
     * @deprecated use .findOne instead of .selectOne
     */
    async selectOne(whereValues) {
        return this.findOne(whereValues);
    }
    // throws if > 1 row matches
    async findOne(whereValues) {
        return await this.find(whereValues).one();
    }
    async findOneRequired(whereValues) {
        return await this.find(whereValues).oneRequired();
    }
    async count(whereValues = {}) {
        const { sql } = this._underlyingDb;
        const whereCondition = WhereCombinedCondition.query(null, whereValues, sql, this._value);
        if (whereCondition === `FALSE`) {
            return 0;
        }
        else if (whereCondition === `TRUE`) {
            const [result] = await this._underlyingDb.query(sql `SELECT count(*) AS count FROM ${this.tableId}`);
            return parseInt(result.count, 10);
        }
        else {
            const [result] = await this._underlyingDb.query(sql `SELECT count(*) AS count FROM ${this.tableId} WHERE ${whereCondition}`);
            return parseInt(result.count, 10);
        }
    }
    async untypedQuery(query) {
        return await this._underlyingDb.query(query);
    }
}
function getTable(tableName, defaultConnection, schemaName, serializeValue, tableSchema) {
    const cache = new WeakMap();
    const bulkOperationOptionsCache = new Map();
    return Object.assign((queryable = defaultConnection) => {
        if (!queryable) {
            throw new Error('You must either provide a "defaultConnection" to pg-typed, or specify a connection when accessing the table.');
        }
        const cached = cache.get(queryable);
        if (cached)
            return cached;
        let bulkOperationsBase = bulkOperationOptionsCache.get(queryable.sql);
        if (tableSchema && !bulkOperationsBase) {
            bulkOperationsBase =
                tableSchema &&
                    getBulkOperationOptionsBase(tableSchema, {
                        sql: queryable.sql,
                        schemaName,
                        serializeValue,
                    });
            bulkOperationOptionsCache.set(queryable.sql, bulkOperationsBase);
        }
        const fresh = new Table(queryable, schemaName
            ? queryable.sql.ident(schemaName, tableName)
            : queryable.sql.ident(tableName), tableName, serializeValue, bulkOperationsBase
            ? { ...bulkOperationsBase, database: queryable }
            : undefined);
        cache.set(queryable, fresh);
        return fresh;
    }, {
        key: (fieldName, condition = {}) => internalInQueryResults((sql) => {
            const whereCondition = WhereCombinedCondition.query(null, condition, sql, serializeValue);
            if (whereCondition === 'FALSE') {
                return 'FALSE';
            }
            const tableId = schemaName
                ? sql.ident(schemaName, tableName)
                : sql.ident(tableName);
            const fieldId = sql.ident(fieldName);
            if (whereCondition === 'TRUE') {
                return sql `SELECT ${fieldId} FROM ${tableId}`;
            }
            else {
                return sql `SELECT ${fieldId} FROM ${tableId} WHERE ${whereCondition}`;
            }
        }),
    });
}
function defineTables(options = {}) {
    if (options.databaseSchema) {
        return Object.fromEntries(options.databaseSchema.map((tableSchema) => [
            tableSchema.name,
            getTable(tableSchema.name, options.defaultConnection, options.schemaName, options.serializeValue
                ? (column, value) => options.serializeValue(tableSchema.name, column, value)
                : getTableSerializeValue(tableSchema), tableSchema),
        ]));
    }
    return new Proxy({}, {
        get: (_target, prop, _receiver) => {
            if (prop === 'then') {
                return undefined;
            }
            const tableName = String(prop);
            return getTable(tableName, options.defaultConnection, options.schemaName, options.serializeValue
                ? (column, value) => options.serializeValue(tableName, column, value)
                : (_column, value) => value);
        },
    });
}
exports.default = defineTables;
function getTableSerializeValue(tableSchema) {
    const jsonColumns = new Set(tableSchema.columns
        .filter((c) => c.typeId === 114 || c.typeId === 3802)
        .map((c) => c.name));
    const jsonArrayColumns = new Set(tableSchema.columns
        .filter((c) => c.typeId === 199 || c.typeId === 3807)
        .map((c) => c.name));
    return tableSchema
        ? (columnName, value) => {
            if (jsonColumns.has(columnName)) {
                return JSON.stringify(value);
            }
            if (jsonArrayColumns.has(columnName) && Array.isArray(value)) {
                return value.map((v) => JSON.stringify(v));
            }
            return value;
        }
        : (_, value) => value;
}
module.exports = Object.assign(defineTables, {
    default: defineTables,
    anyOf,
    allOf,
    not,
    inQueryResults,
    lessThan,
    jsonPath,
    caseInsensitive,
    greaterThan,
    and,
    or,
    isNoResultFoundError,
    isMultipleResultsFoundError,
});
//# sourceMappingURL=index.js.map