"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeQuery = void 0;

const pg_1 = require("@databases/pg");

const TypeCategory_1 = require("./enums/TypeCategory");

const TypeKind_1 = require("./enums/TypeKind");

const getAttributes_1 = require("./getAttributes");

const getEnumValues_1 = require("./getEnumValues");

async function getTypes(connection, query = {}) {
  const conditions = typeQuery(query);
  const typeRecords = await connection.query(pg_1.sql`
    SELECT
      ns.oid AS "schemaID",
      ns.nspname AS "schemaName",
      ty.oid as "typeID",
      ty.typname AS "typeName",
      ty.typtype AS "kind",
      ty.typcategory AS "category",
      ty.typrelid AS "classID",
      subt.oid as "subtypeID",
      subt.typname AS "subtypeName",
      baset.oid as "basetypeID",
      baset.typname AS "basetypeName",
      
      obj_description(ty.oid, 'pg_type') as "comment"
    FROM pg_catalog.pg_type ty
    INNER JOIN pg_catalog.pg_namespace ns
      ON (ty.typnamespace = ns.oid)
    LEFT OUTER JOIN pg_catalog.pg_type subt
      ON (ty.typelem = subt.oid)
    LEFT OUTER JOIN pg_catalog.pg_type baset
      ON (ty.typbasetype = baset.oid)
    ${conditions.length ? pg_1.sql`WHERE ${pg_1.sql.join(conditions, pg_1.sql` AND `)}` : pg_1.sql``}
    ORDER BY ns.nspname ASC, ty.typname ASC, subt.typname ASC, baset.typname ASC
  `);
  return Promise.all(typeRecords.map(async tr => {
    const base = {
      schemaID: tr.schemaID,
      schemaName: tr.schemaName,
      typeID: tr.typeID,
      typeName: tr.typeName,
      kind: tr.kind,
      category: tr.category,
      comment: tr.comment
    };

    switch (base.kind) {
      case TypeKind_1.default.Array:
      case TypeKind_1.default.Base:
        if (tr.category === TypeCategory_1.default.Array) {
          return { ...base,
            kind: TypeKind_1.default.Array,
            subtypeID: tr.subtypeID,
            subtypeName: tr.subtypeName
          };
        } else {
          return { ...base,
            kind: TypeKind_1.default.Base,
            subtypeID: tr.subtypeID,
            subtypeName: tr.subtypeName
          };
        }

      case TypeKind_1.default.Composite:
        return { ...base,
          kind: TypeKind_1.default.Composite,
          classID: tr.classID,
          attributes: await getAttributes_1.default(connection, {
            classID: tr.classID
          })
        };

      case TypeKind_1.default.Domain:
        return { ...base,
          kind: TypeKind_1.default.Domain,
          basetypeID: tr.basetypeID,
          basetypeName: tr.basetypeName
        };

      case TypeKind_1.default.Enum:
        return { ...base,
          kind: TypeKind_1.default.Enum,
          values: (await getEnumValues_1.default(connection, {
            typeID: tr.typeID
          })).map(v => v.value)
        };

      case TypeKind_1.default.Pseudo:
        return { ...base,
          kind: TypeKind_1.default.Pseudo
        };

      default:
        const kind = base.kind;
        return { ...base,
          kind
        };
    }
  }));
}

exports.default = getTypes;

function typeQuery(query) {
  const conditions = [];

  if (query.schemaID) {
    conditions.push(pg_1.sql`ns.oid = ${query.schemaID}`);
  }

  if (query.schemaName) {
    conditions.push(pg_1.sql`ns.nspname = ${query.schemaName}`);
  }

  if (query.typeID) {
    conditions.push(pg_1.sql`ty.oid = ${query.typeID}`);
  }

  if (query.typeName) {
    conditions.push(pg_1.sql`ty.typname = ${query.typeName}`);
  }

  if (query.category) {
    conditions.push(pg_1.sql`ty.typcategory = ${query.category}`);
  }

  return conditions;
}

exports.typeQuery = typeQuery;