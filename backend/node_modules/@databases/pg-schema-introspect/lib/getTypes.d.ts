import { Queryable } from '@databases/pg';
import TypeCateogry from './enums/TypeCategory';
import TypeKind from './enums/TypeKind';
import { Attribute } from './getAttributes';
export interface TypeQuery {
    schemaID?: number;
    schemaName?: string;
    typeID?: number;
    typeName?: string;
    category?: TypeCateogry;
}
export interface TypeRecord {
    schemaID: number;
    schemaName: string;
    typeID: number;
    typeName: string;
    kind: TypeKind;
    category: TypeCateogry;
    /**
     * classID if composite type
     */
    classID?: number;
    subtypeID?: number;
    subtypeName?: string;
    basetypeID?: number;
    basetypeName?: string;
    comment: string | null;
}
export interface TypeBase {
    schemaID: number;
    schemaName: string;
    typeID: number;
    typeName: string;
    kind: TypeKind;
    category: TypeCateogry;
    comment: string | null;
}
export interface ArrayType extends TypeBase {
    kind: TypeKind.Array;
    subtypeID: number;
    subtypeName: string;
}
export interface BaseType extends TypeBase {
    kind: TypeKind.Base;
    subtypeID?: number;
    subtypeName?: string;
}
export interface CompositeType extends TypeBase {
    kind: TypeKind.Composite;
    classID: number;
    attributes: Attribute[];
}
export interface DomainType extends TypeBase {
    kind: TypeKind.Domain;
    basetypeID: number;
    basetypeName: string;
}
export interface EnumType extends TypeBase {
    kind: TypeKind.Enum;
    values: string[];
}
export interface PseudoType extends TypeBase {
    kind: TypeKind.Pseudo;
}
export declare type Type = ArrayType | BaseType | CompositeType | DomainType | EnumType | PseudoType;
export default function getTypes(connection: Queryable, query?: TypeQuery): Promise<Type[]>;
export declare function typeQuery(query: TypeQuery): import("@databases/sql/lib/web").SQLQuery[];
