import { PrintOptions } from '@databases/shared-print-types';
import PgConfig from '@databases/pg-config';
import TypeID from './TypeID';
export default class PgPrintOptions implements PrintOptions<TypeID> {
    private readonly _config;
    constructor(config: Partial<PgConfig['types']>);
    private _v;
    getSchemaJsonFileName(): string | null;
    get domainTypeMode(): import("@databases/pg-config").PgTypesDomainTypeMode;
    get enumTypeMode(): "enum" | "union_alias" | "union_alias_with_object" | "inline";
    get primaryKeyTypeMode(): "strict_brand" | "loose_brand" | "inline_strict_brand" | "inline_loose_brand" | "inline_no_brand";
    get columnTypeOverrides(): {
        [x: string]: string | undefined;
    };
    get typeOverrides(): {
        [x: string]: string | undefined;
    };
    getExportPriority(id: TypeID): number;
    getExportNameTemplate(id: TypeID): string;
    getFilenameTemplate(id: TypeID): string;
    getTemplateValues(id: TypeID): any;
}
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare type CheckForUnion<T> = [T] extends [UnionToIntersection<T>] ? unknown : never;
/**
 * Only accept a single type, not a union of types
 */
export declare type Literal<TValue> = TValue & CheckForUnion<TValue>;
export {};
