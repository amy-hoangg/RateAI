"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const PrintOptions_1 = require("./PrintOptions");
class ImportState {
    constructor(file) {
        this._namedImports = new Map();
        this.file = file;
    }
    getImport(fileExport) {
        this._namedImports.set(fileExport.exportName, fileExport);
        return fileExport.exportName;
    }
    getImportStatement(relativePath) {
        var _a;
        const defaultImport = (_a = [...this._namedImports.values()].find((v) => v.isDefaultExport())) === null || _a === void 0 ? void 0 : _a.exportName;
        const namedImports = [...this._namedImports.values()]
            .filter((v) => !v.isDefaultExport())
            .map((v) => v.exportName);
        const specifiers = [];
        if (defaultImport) {
            specifiers.push(defaultImport);
        }
        if (namedImports.length) {
            specifiers.push(`{${namedImports.sort().join(', ')}}`);
        }
        return `import ${specifiers.join(', ')} from '${relativePath}'`;
    }
}
class FileContent {
    constructor(file, options) {
        this._imports = new Map();
        this._declarationNames = new Set();
        this._declarations = [];
        this._reExports = { type: [], value: [] };
        this.file = file;
        this._options = options;
    }
    getDefaultName() {
        if (this._defaultName === undefined) {
            this._defaultName = this._defaultCandidate
                ? (0, PrintOptions_1.resolveExportName)(this._defaultCandidate, this._options)
                : null;
        }
        return this._defaultName;
    }
    _getImportState(file) {
        if (file === this.file) {
            return {
                getImport: (n) => n.exportName,
            };
        }
        const cachedImportState = this._imports.get(file);
        if (cachedImportState !== undefined) {
            return cachedImportState;
        }
        const newImportState = new ImportState(file);
        this._imports.set(file, newImportState);
        return newImportState;
    }
    pushDeclaration(typeID, mode, declaration) {
        const identifierName = (0, PrintOptions_1.resolveExportName)(typeID, this._options);
        if (!this._declarationNames.has(identifierName)) {
            if (this._defaultName === undefined &&
                (0, PrintOptions_1.isDefaultExportCandidate)(typeID, this._options)) {
                if (this._defaultCandidate === undefined) {
                    this._defaultCandidate = typeID;
                }
                else {
                    const oldWeight = this._options.getExportPriority(this._defaultCandidate);
                    const newWeight = this._options.getExportPriority(typeID);
                    if (oldWeight === newWeight) {
                        this._defaultName = null;
                    }
                    else if (oldWeight > newWeight) {
                        this._defaultCandidate = typeID;
                    }
                }
            }
            this._declarationNames.add(identifierName);
            const declarationLines = declaration(identifierName, {
                getImport: (id) => this._getImportState(id.file).getImport(id),
            });
            this._declarations.push({
                name: identifierName,
                src: () => [
                    ...declarationLines,
                    this.getDefaultName() === identifierName
                        ? `export default ${identifierName};`
                        : `export ${mode === 'type' ? 'type ' : ''}{${identifierName}}`,
                ],
            });
        }
        return {
            mode,
            file: this.file,
            isDefaultExport: () => this.getDefaultName() === identifierName,
            exportName: identifierName,
        };
    }
    pushReExport(dest, source) {
        const identifierName = (0, PrintOptions_1.resolveExportName)(dest, this._options);
        if (this._declarationNames.has(identifierName)) {
            return;
        }
        const importedName = this._getImportState(source.file).getImport(source);
        this._declarationNames.add(identifierName);
        this._reExports[source.mode].push({
            source: importedName,
            dest: identifierName,
        });
    }
    getContent() {
        return ([
            ...(this._imports.size
                ? [
                    [...this._imports.values()]
                        .sort((a, b) => (a.file < b.file ? -1 : 1))
                        .map((imp) => {
                        const relativePath = (0, path_1.relative)((0, path_1.dirname)(this.file), imp.file);
                        return imp.getImportStatement(`${relativePath[0] === '.' ? '' : './'}${relativePath.replace(/(\.d)?\.tsx?$/, '')}`);
                    })
                        .join('\n'),
                ]
                : []),
            ...this._declarations
                .sort((a, b) => (a.name < b.name ? -1 : 1))
                .map((v) => v.src().join('\n')),
            ...(this._reExports.type.length
                ? [
                    `export type {\n${this._reExports.type
                        .sort((a, b) => (a.dest < b.dest ? -1 : 1))
                        .map((t) => t.source === t.dest
                        ? `  ${t.source},`
                        : `  ${t.source} as ${t.dest},`)
                        .join(`\n`)}\n}`,
                ]
                : []),
            ...(this._reExports.value.length
                ? [
                    `export {\n${this._reExports.value
                        .sort((a, b) => (a.dest < b.dest ? -1 : 1))
                        .map((t) => t.source === t.dest
                        ? `  ${t.source},`
                        : `  ${t.source} as ${t.dest},`)
                        .join(`\n`)}\n}`,
                ]
                : []),
        ].join('\n\n') + '\n');
    }
}
class PrintContext {
    constructor(options) {
        this._files = new Map();
        this._rawFiles = new Map();
        this.options = options;
    }
    _pushDeclaration(id, mode, declaration) {
        const file = (0, PrintOptions_1.resolveFilename)(id, this.options);
        const fileContent = mapGetOrSet(this._files, file, () => new FileContent(file, this.options));
        return fileContent.pushDeclaration(id, mode, declaration);
    }
    pushTypeDeclaration(id, declaration) {
        return this._pushDeclaration(id, 'type', declaration);
    }
    pushReExport(id, from) {
        const file = (0, PrintOptions_1.resolveFilename)(id, this.options);
        const fileContent = mapGetOrSet(this._files, file, () => new FileContent(file, this.options));
        fileContent.pushReExport(id, from);
    }
    pushValueDeclaration(id, declaration) {
        return this._pushDeclaration(id, 'value', declaration);
    }
    writeFile(filename, content) {
        if (this._rawFiles.has(filename)) {
            throw new Error(`Cannot write the same file multiple times: ${filename}`);
        }
        this._rawFiles.set(filename, content);
    }
    getFiles() {
        return [
            ...[...this._files.values()].map((file) => ({
                filename: file.file,
                content: file.getContent(),
            })),
            ...[...this._rawFiles].map(([filename, content]) => ({
                filename,
                content,
            })),
        ];
    }
}
exports.default = PrintContext;
function mapSetAndReturn(map, key, value) {
    map.set(key, value);
    return value;
}
function mapGetOrSet(map, key, value) {
    const cached = map.get(key);
    if (cached !== undefined)
        return cached;
    return mapSetAndReturn(map, key, value());
}
//# sourceMappingURL=PrintContext.js.map