"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const crypto_1 = require("crypto");
const mkdirp_1 = require("mkdirp");
async function writeFiles({ directory, context, generatedStatement, }) {
    const files = context.getFiles();
    const filenames = new Set(files.map((f) => f.filename));
    (0, mkdirp_1.sync)(directory);
    // delete files that would no longer be output
    await Promise.all((await fs_1.promises.readdir(directory))
        .filter((fileName) => !filenames.has(fileName))
        .map(async (fileName) => {
        const filePath = (0, path_1.join)(directory, fileName);
        if ((await fs_1.promises.stat(filePath)).isFile()) {
            const src = await fs_1.promises.readFile(filePath, 'utf8');
            if (src.includes(generatedStatement)) {
                console.info(`Deleting: ${fileName}`);
                await fs_1.promises.unlink(filePath);
            }
        }
    }));
    await Promise.all(files.map(async (f) => {
        const filename = (0, path_1.join)(directory, f.filename);
        if (filename.endsWith(`.ts`)) {
            const content = f.content.trim();
            const checksum = `Checksum: ${(0, crypto_1.createHash)('sha512')
                .update(content)
                .digest('base64')}`;
            try {
                const existingSource = await fs_1.promises.readFile(filename, 'utf8');
                if (existingSource.includes(checksum)) {
                    return;
                }
                console.info(`Updating: ${f.filename}`);
            }
            catch (ex) {
                if (ex.code !== 'ENOENT') {
                    throw ex;
                }
                console.info(`Writing: ${f.filename}`);
            }
            await fs_1.promises.writeFile(filename, [
                `/**`,
                ` * !!! This file is autogenerated do not edit by hand !!!`,
                ` *`,
                ` * ${generatedStatement}`,
                ` * ${checksum}`,
                ' */',
                '',
                `/* eslint-disable */`,
                `// tslint:disable`,
                ``,
                content,
                '',
            ].join('\n'));
        }
        else {
            try {
                const existingSource = await fs_1.promises.readFile(filename, 'utf8');
                if (existingSource === f.content) {
                    return;
                }
                console.info(`Updating: ${f.filename}`);
            }
            catch (ex) {
                if (ex.code !== 'ENOENT') {
                    throw ex;
                }
                console.info(`Writing: ${f.filename}`);
            }
            await fs_1.promises.writeFile(filename, f.content);
        }
    }));
}
exports.default = writeFiles;
//# sourceMappingURL=writeFiles.js.map