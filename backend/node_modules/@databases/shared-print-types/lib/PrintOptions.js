"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFilename = exports.resolveExportName = exports.isDefaultExportCandidate = void 0;
const camelcase = require("camelcase");
const pascalcase = require("uppercamelcase");
const pluralize_1 = require("pluralize");
function parseTemplate(str) {
    const variables = [];
    const result = [];
    let inVariables = false;
    for (const part of str.split('{{')) {
        if (inVariables) {
            const split = part.split('}}');
            if (split.length !== 2) {
                throw new Error(`Mismatched parentheses: ${str}`);
            }
            const [placeholder, plainString] = split;
            const [variable, ...filters] = placeholder
                .split('|')
                .map((str) => str.trim());
            variables.push(variable);
            result.push((values) => {
                if (!(variable in values)) {
                    throw new Error(`Unrecognized variable ${variable} in ${str}`);
                }
                return filters.reduce((value, filter) => {
                    if (filter.startsWith(`replace`)) {
                        const parts = filter.split(` `);
                        if (parts.length !== 3 || parts[0] !== 'replace') {
                            throw new Error(`Unrecognized filter in type generation config, "${filter}". Replace filters should be in the format {{ variable | replace "some-regex" "some-string" }}: ${str}`);
                        }
                        return `${value}`.replace(new RegExp(JSON.parse(parts[1]), `g`), JSON.parse(parts[2]));
                    }
                    switch (filter) {
                        case 'pascal-case':
                            return pascalcase(value);
                        case 'camel-case':
                            return camelcase(value);
                        case 'plural':
                            return (0, pluralize_1.plural)(value);
                        case 'singular':
                            return (0, pluralize_1.singular)(value);
                        default:
                            throw new Error(`Unrecognized filter in type generation config, "${filter}" in: ${str}`);
                    }
                }, values[variable]);
            });
            result.push(() => plainString);
        }
        else {
            inVariables = true;
            result.push(() => part);
        }
    }
    return {
        variables,
        applyTemplate: (value) => result.map((r) => r(value)).join(''),
    };
}
function isDefaultExportCandidate(id, options) {
    const allowedValues = new Set(parseTemplate(options.getFilenameTemplate(id)).variables);
    return parseTemplate(options.getExportNameTemplate(id)).variables.every((v) => allowedValues.has(v));
}
exports.isDefaultExportCandidate = isDefaultExportCandidate;
function resolveExportName(id, options) {
    return parseTemplate(options.getExportNameTemplate(id)).applyTemplate(options.getTemplateValues(id));
}
exports.resolveExportName = resolveExportName;
function resolveFilename(id, options) {
    return parseTemplate(options.getFilenameTemplate(id)).applyTemplate(options.getTemplateValues(id));
}
exports.resolveFilename = resolveFilename;
//# sourceMappingURL=PrintOptions.js.map