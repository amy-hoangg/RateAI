"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.positionalEnumString = exports.positionalStringList = exports.parsedPositionalStringList = exports.positionalString = exports.parsedPositionalString = exports.integer = exports.enumString = exports.stringList = exports.string = exports.parsedStringList = exports.parsedString = exports.flag = void 0;
const helpers_1 = require("./helpers");
function flag(keys, name) {
    const shorthands = new Set(keys.filter((k) => /^\-[a-z]$/i.test(k)).map((k) => k[1]));
    const negations = keys.map((key) => key.replace(/^\-\-?/, '--no-'));
    return (input, parsed) => {
        for (const key of keys) {
            if (input[0] === key) {
                if (parsed[name] !== undefined) {
                    return (0, helpers_1.invalid)(`You have specified more than one value for ${key}`);
                }
                return (0, helpers_1.valid)(parsed, name, true, input.slice(1));
            }
        }
        for (const key of negations) {
            if (input[0] === key) {
                if (parsed[name] !== undefined) {
                    return (0, helpers_1.invalid)(`You have specified more than one value for ${key}`);
                }
                return (0, helpers_1.valid)(parsed, name, false, input.slice(1));
            }
        }
        if (shorthands.size && /^\-[a-z]+$/i.test(input[0])) {
            for (const s of input[0].substr(1).split('')) {
                if (shorthands.has(s)) {
                    if (parsed[name] !== undefined) {
                        return (0, helpers_1.invalid)(`You have specified more than one value for -${s}`);
                    }
                    return (0, helpers_1.valid)(parsed, name, true, [
                        input[0].replace(s, ''),
                        ...input.slice(1),
                    ]);
                }
            }
        }
        return undefined;
    };
}
exports.flag = flag;
function parsedString(keys, name, parse) {
    return (input, parsed) => {
        for (const key of keys) {
            if (input[0] === key) {
                if (parsed[name] !== undefined) {
                    return (0, helpers_1.invalid)(`You have specified more than one value for ${key}`);
                }
                if (input.length < 2) {
                    return (0, helpers_1.invalid)(`Missing string value for ${key}`);
                }
                const result = parse(input[1], key);
                if (!result.valid)
                    return result;
                return (0, helpers_1.valid)(parsed, name, result.value, input.slice(2));
            }
        }
        return undefined;
    };
}
exports.parsedString = parsedString;
function parsedStringList(keys, name, parse) {
    return (input, parsed) => {
        for (const key of keys) {
            if (input[0] === key) {
                if (input.length < 2) {
                    return (0, helpers_1.invalid)(`Missing string value for ${key}`);
                }
                const result = parse(input[1], key);
                if (!result.valid)
                    return result;
                return (0, helpers_1.valid)(parsed, name, [...(parsed[name] || []), result.value], input.slice(2));
            }
        }
        return undefined;
    };
}
exports.parsedStringList = parsedStringList;
function string(keys, name) {
    return parsedString(keys, name, (value) => (0, helpers_1.valid)(value));
}
exports.string = string;
function stringList(keys, name) {
    return parsedStringList(keys, name, (value) => (0, helpers_1.valid)(value));
}
exports.stringList = stringList;
function enumString(keys, name, values) {
    if (values.length === 0) {
        throw new Error('You must provide at least one value to enumString');
    }
    return parsedString(keys, name, (value, key) => {
        if (values.includes(value)) {
            return (0, helpers_1.valid)(value);
        }
        else {
            return (0, helpers_1.invalid)(values.length === 1
                ? `Expected ${key} to be ${values[0]}`
                : `Expected ${key} to be one of ${values
                    .slice(0, values.length - 1)
                    .map((v) => `"${v}"`)
                    .join(`, `)} or "${values[values.length - 1]}"`);
        }
    });
}
exports.enumString = enumString;
function integer(keys, name) {
    return parsedString(keys, name, (str, key) => {
        if (!/^\-?\d+$/.test(str)) {
            return (0, helpers_1.invalid)(`${key} must be an integer`);
        }
        const value = parseInt(str, 10);
        if (value > Number.MAX_SAFE_INTEGER) {
            return (0, helpers_1.invalid)(`${key} is greater than the max safe integer`);
        }
        if (value < Number.MIN_SAFE_INTEGER) {
            return (0, helpers_1.invalid)(`${key} is less than the min safe integer`);
        }
        return (0, helpers_1.valid)(value);
    });
}
exports.integer = integer;
function parsedPositionalString(name, parse) {
    return (input, parsed) => {
        if (parsed[name] !== undefined) {
            return undefined;
        }
        const result = parse(input[0]);
        if (!(result === null || result === void 0 ? void 0 : result.valid))
            return result;
        return (0, helpers_1.valid)(parsed, name, result.value, input.slice(1));
    };
}
exports.parsedPositionalString = parsedPositionalString;
function positionalString(name) {
    return parsedPositionalString(name, (value) => {
        if (value[0] === '-')
            return undefined;
        return (0, helpers_1.valid)(value);
    });
}
exports.positionalString = positionalString;
function parsedPositionalStringList(name, parse, options = {}) {
    return (input, parsed) => {
        if (options.eager) {
            const results = [];
            let i = 0;
            for (; i < input.length; i++) {
                const result = parse(input[i]);
                if (!result)
                    break;
                if (!result.valid)
                    return result;
                results.push(input[i]);
            }
            if (i === 0)
                return undefined;
            return (0, helpers_1.valid)(parsed, name, [...(parsed[name] || []), ...results], input.slice(i));
        }
        const result = parse(input[0]);
        if (!(result === null || result === void 0 ? void 0 : result.valid))
            return result;
        return (0, helpers_1.valid)(parsed, name, [...(parsed[name] || []), result.value], input.slice(1));
    };
}
exports.parsedPositionalStringList = parsedPositionalStringList;
function positionalStringList(name, options = {}) {
    return parsedPositionalStringList(name, (value) => {
        if (value[0] === '-')
            return undefined;
        return (0, helpers_1.valid)(value);
    }, options);
}
exports.positionalStringList = positionalStringList;
function positionalEnumString(name, values) {
    return parsedPositionalString(name, (value) => {
        if (value[0] === '-')
            return undefined;
        if (values.includes(value)) {
            return (0, helpers_1.valid)(value);
        }
        else {
            return (0, helpers_1.invalid)(values.length === 1
                ? `Expected ${name} to be ${values[0]}`
                : `Expected ${name} to be one of ${values
                    .slice(0, values.length - 1)
                    .map((v) => `"${v}"`)
                    .join(`, `)} or "${values[values.length - 1]}"`);
        }
    });
}
exports.positionalEnumString = positionalEnumString;
//# sourceMappingURL=parameters.js.map